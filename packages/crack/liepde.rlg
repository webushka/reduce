%*******************************************************************%
%                                                                   %
%                      L I E P D E . T S T                          %
%                      -------------------                          %
%  liepde.tst contains test examples for the program liepde.red.    %
%                                                                   %
%  Author of this file: Thomas Wolf                                 %
%  Date:  21. April 1998, 6. May 2003, 14. Feb 2006                 %
%                                                                   %
%  Details about the syntax of liepde.red are given in liepde.tex.  %
%                                                                   %
%  To run this demo you need to load liepde and crack through       %
%     load crack,liepde$                                            %
%  and to read in this file as                                      %
%     in "liepde.tst"$                                              %
%  If you got the source code of a newer version of liepde then     %
%  either read it in through                                        %
%     in "crack.red","liepde.red"$                                  %
%  (with the appropriate directory name in front of liepde.red)     %
%  or, to speed up the calculation, you compile before with         %
%     faslout "crack"$                                              %
%     in "crack.red"$                                               %
%     faslend$                                                      %
%     faslout "liepde"$                                             %
%     in "liepde.red"$                                              %
%     faslend$                                                      %
%  and then load both it with                                       %
%     load crack,liepde$                                            %
%                                                                   %
%*******************************************************************%

lisp(depl!*:=nil)$

     % clearing of all dependences
setcrackflags()$


*** setcrackflags declared operator 

lisp(print_:=nil)$

       
on dfprint$



comment
-------------------------------------------------------
The following runs demonstrate the program LIEPDE for 
the computation of infinitesimal symmetries. Times given
below refer to a 8 MB session under LINUX on a 133 MHz
Pentium PC with the CRACK version of April 1998 running
PSL Reduce.
-------------------------------------------------------$


lisp(prelim_:=nil)$

      % not necessary as this is the default value
lisp(individual_:=nil)$

  % not necessary as this is the default value

comment
-------------------------------------------------------
The first example is a single ODE with a parametric
function f=f(x) for which point symmetries are to be
determined.
(Time ~ 6 sec.)$

write"-------------------------------------------------------"$


-------------------------------------------------------


lisp(freeint_:=nil)$

 % This enables the solution of differential equ.s in
                     % which unevaluated integrals remain. This becomes
                     % necessary in this example through the parametric
                     % function f=f(x)
depend y,x$


depend f,x$


liepde({df(y,x,2)=-(y+3*f)*df(y,x)+y**3-f*y**2-(2*f**2+df(f,x))*y, 
        {y}, {x}},
       {"point"},{},{})$



The ODE under investigation is :

                                 2        2    3
y  = - f *y - 3*y *f - y *y - 2*f *y - f*y  + y
 2x     x        x      x

for the function(s) : 

y(x)


odesolve_ needs to be an integer: nil is invalid
subst_0 needs to be an integer: nil is invalid
subst_1 needs to be an integer: nil is invalid
subst_2 needs to be an integer: nil is invalid
subst_3 needs to be an integer: nil is invalid
target_limit_0 needs to be an integer: nil is invalid
target_limit_1 needs to be an integer: nil is invalid
target_limit_2 needs to be an integer: nil is invalid
cost_limit5 needs to be an integer: nil is invalid
max_gc_fac needs to be an integer: nil is invalid
max_gc_gb needs to be an integer: nil is invalid
max_gc_ode needs to be an integer: nil is invalid
max_gc_red_len needs to be an integer: nil is invalid
max_gc_short needs to be an integer: nil is invalid
max_gc_ss needs to be an integer: nil is invalid
maxalgsys_ needs to be an integer: nil is invalid
max_eqn_to_conti needs to be an integer: nil is invalid
nfct_ needs to be an integer: nil is invalid
nequ_ needs to be an integer: nil is invalid
low_gensep needs to be an integer: nil is invalid
high_gensep needs to be an integer: nil is invalid
length_inc_alg needs to be a number: nil is invalid
length_inc_dec needs to be a number: nil is invalidThe global variable 
length_inc_dec has an incorrect value, please check!
*****   

nodepnd {y,f}$


*** nodepnd declared operator 

lisp(freeint_:=t)$

   % Because the simplification of differential
                     % expressions which involve unevaluated integrals
                     % may provide difficulties such solutions involving
                     % unevaluated integrals are disabled.

comment
-------------------------------------------------------
The following example demonstrates a number of things.
The Burgers equation is investigated concerning third
order symmetries. The equation is used to substitute
df(u,t) and all derivatives of df(u,t). This computation
also shows that any equations that remain unsolved are
returned, like in this case the heat quation.
(Time ~ 15 sec.)$

write"-------------------------------------------------------"$


-------------------------------------------------------


nodepnd {u}$


depend u,t,x$


liepde({df(u,t)=df(u,x,2)+df(u,x)**2,{u},{t,x}},{"general",3},{},{})$



The PDE under investigation is :

           2
u =u   + u
 t  2x    x

for the function(s) : 

u(x,t)



odesolve_ needs to be an integer: nil is invalid
subst_0 needs to be an integer: nil is invalid
subst_1 needs to be an integer: nil is invalid
subst_2 needs to be an integer: nil is invalid
subst_3 needs to be an integer: nil is invalid
target_limit_0 needs to be an integer: nil is invalid
target_limit_1 needs to be an integer: nil is invalid
target_limit_2 needs to be an integer: nil is invalid
cost_limit5 needs to be an integer: nil is invalid
max_gc_fac needs to be an integer: nil is invalid
max_gc_gb needs to be an integer: nil is invalid
max_gc_ode needs to be an integer: nil is invalid
max_gc_red_len needs to be an integer: nil is invalid
max_gc_short needs to be an integer: nil is invalid
max_gc_ss needs to be an integer: nil is invalid
maxalgsys_ needs to be an integer: nil is invalid
max_eqn_to_conti needs to be an integer: nil is invalid
nfct_ needs to be an integer: nil is invalid
nequ_ needs to be an integer: nil is invalid
low_gensep needs to be an integer: nil is invalid
high_gensep needs to be an integer: nil is invalid
length_inc_alg needs to be a number: nil is invalid
length_inc_dec needs to be a number: nil is invalidThe global variable 
length_inc_dec has an incorrect value, please check!
*****   


comment
-------------------------------------------------------
Now the same equation is investigated, this time only
df(u,x,2) and its derivatives are substituted. As a
consequence fewer jet-variables (u-derivatives of lower
order) are generated in the process of formulating the
symmetry conditions. Fewer jet-variables in which the
conditions have to be fulfilled identically mean less
overdetermined conditions and more solutions which to
compute takes longer than before.
(Time ~ 85 sec.)$

write"-------------------------------------------------------"$


-------------------------------------------------------


liepde({df(u,x,2)=df(u,t)-df(u,x)**2,{u},{t,x}},{"general",3},{},{})$


***** Not all functions do depend on all variables. 

nodepnd {u}$



comment
-------------------------------------------------------
The following example includes the Karpman equations
for three unknown functions in 4 variables. 

If point symmetries are to be computed for a single
equation or a system of equations of higher than first
order then there is the option to formulate at first
preliminary conditions for each equation, have CRACK
solving these conditions before the full set of conditions
is formulated and solved. This strategy is adopted if a
lisp flag prelim_ has the value t. The default value
is nil. 

Similarly, if a system of equations is to be investigated
and a flag individual_ has the value t then symmetry
conditions are formulated and investigated for each
individual equation successively. The default value is nil.

It is advantageous to split a large set of conditions
into smaller sets to be investigated successively if
each set is sufficiently overdetermined to be solvable
quickly. Then any substitutions are done in the smaller
set and the next set of conditions is shorter. For
example, for the Karpman equations below the speedup for
prelim_:=t and individual_:=t is a factor of 10.
(Time ~ 1 min.)$

write"-------------------------------------------------------"$


-------------------------------------------------------


lisp(prelim_:=t)$


lisp(individual_:=t)$



depend r,x,y,z,t$


depend f,x,y,z,t$


depend v,x,y,z,t$



liepde({

first 
solve(
        {df(r,t) + w1*df(r,z)
         + s1*(df(r,x)*df(f,x)+df(r,y)*df(f,y)+r*df(f,x,2)/2+r*df(f,y,2)/2) 
         + s2*(df(r,z)*df(f,z)+r*df(f,z,2)/2),
 
         df(f,t) + w1*df(f,z) 
         - (s1*(df(r,x,2)/r+df(r,y,2)/r-df(f,x)**2-df(f,y)**2) +
            s2*(df(r,z,2)/r-df(f,z)**2))/2 + a1*v,
       
         df(v,t,2) - w2**2*(df(v,x,2)+df(v,y,2)+df(v,z,2))
         - 2*a2*r*(df(r,x,2)+df(r,y,2)+df(r,z,2))
         - 2*a2*(df(r,x)**2+df(r,y)**2+df(r,z)**2)},
         
        {df(v,x,2), df(r,x,2), df(f,x,2)}         
 
     )         
         , {r,f,v}, {x,y,z,t}},

       {"point"}, 
       
       {},{})$



The PDE-system under investigation is :

                 2       2     2          2     2          2     2
v  =( - 4*f *a2*r  - 2*f  *a2*r *s1 - 2*f  *a2*r *s1 - 2*f  *a2*r *s2
 2x        t            x                y                z

                 2          2             2
      - 4*f *a2*r *w1 - 2*r  *a2*s1 - 2*r  *a2*s1 - 2*r  *a2*r*s1
           z               x             y             2z

                            2                           2            2
      + 2*r  *a2*r*s2 - 2*r  *a2*s1 + v  *s1 - v  *s1*w2  - v  *s1*w2
           2z              z           2t       2y           2z

                 2          2
      - 4*a1*a2*r *v)/(s1*w2 )

                2          2          2
r  =(2*f *r + f  *r*s1 + f  *r*s1 + f  *r*s2 + 2*f *r*w1 - r  *s1 - r  *s2
 2x     t      x          y          z            z         2y       2z

      + 2*a1*r*v)/s1

f  =
 2x

  - 2*f *r *s1 - f  *r*s1 - 2*f *r *s1 - f  *r*s2 - 2*f *r *s2 - 2*r  - 2*r *w1
       x  x       2y           y  y       2z           z  z         t      z
--------------------------------------------------------------------------------
                                      r*s1

for the function(s) : 

r(t,z,y,x), f(t,z,y,x), v(t,z,y,x)


***** One substitution can be made in the lhs of another substitution! 


nodepnd {r,f,v}$



comment
-------------------------------------------------------
In the following example a system of two equations (by
V.Sokolov) is investigated concerning a special ansatz for
4th order symmetries. The ansatz for the symmetries includes
two unknown functions f,g. Because x is the second variable
in the list of variables {t,x}, the name u!`2 stands for
df(u,x).
Because higher order symmetries are investigated we have
to set prelim_:=nil. The symmetries to be calculated are
lengthy and therefore conditions are not very overdetermined.
In that case CRACK can take long to solve a single 
subset of conditions. The complete set of conditions would
have been more overdetermined and easier to solve. Therefore
the advantage of first formulating all conditions and then
solving them together with one CRACK call is that having
more equations, the chance of finding short integrable
equations among then is higher, i.e. CRACK has more freedom
in optimizing the computation. Therefore individual_:=nil
is more appropriate in this example.

Because 4th order conditions are to be computed the
`binding stack size' is increased.
(Time ~ 5 min.)$

write"-------------------------------------------------------"$


-------------------------------------------------------


lisp(prelim_:=nil)$


lisp(individual_:=nil)$


lisp(if getd 'set_bndstk_size then set_bndstk_size(7000))$



nodepnd {u,v}$


depend  u,x,t$


depend  v,x,t$



des:={df(u,t)=+df(u,x,2) + (u + v)*df(u,x) + u*df(v,x),
      df(v,t)=-df(v,x,2) + (u + v)*df(v,x) + v*df(u,x)
     }$



nodepnd {f,g}$


depend f,t,x,u,v,u!`2,v!`2,u!`2!`2,v!`2!`2,u!`2!`2!`2,v!`2!`2!`2$


depend g,t,x,u,v,u!`2,v!`2,u!`2!`2,v!`2!`2,u!`2!`2!`2,v!`2!`2!`2$


liepde({des,{u,v},{t,x}},
       {xi_t=0,
        xi_x=0,
        eta_u=+df(u,x,4)+f,
        eta_v=-df(v,x,4)+g
       },
       {f,g},{}
      )$



The PDE-system under investigation is :

u =u   + u *u + u *v + v *u
 t  2x    x      x      x

v =u *v - v   + v *u + v *v
 t  x      2x    x      x

for the function(s) : 

u(t,x), v(t,x)


***** One substitution can be made in the lhs of another substitution! 

nodepnd {f,g}$



comment
-------------------------------------------------------
A relative new feature of the package CRACK is to be able to solve
non-linear problems where unknowns to be determined may appear in
exponents. This is the case when parameters in a differential equation
is to be determined such that symmetries exist. The following ODE is
such an example where the exponent `n' is to be determined so that
the ODE has one or more symmetries. 
  Something else is demonstrated in the following example. The
parameter prolong_order allows to compute and print the prolongation
of each of the found symmetry generators. In the following example
all found symmetry generators are prolonged to order 2.$

write"-------------------------------------------------------"$


-------------------------------------------------------


lisp(prolong_order:=2)$


depend y,x$


liepde({df(y,x,2) = x**n*y**2,y,x},{"point"},{n},{})$



The ODE under investigation is :

     n  2
y  =x *y
 2x

for the function(s) : 

y(x)


odesolve_ needs to be an integer: nil is invalid
subst_0 needs to be an integer: nil is invalid
subst_1 needs to be an integer: nil is invalid
subst_2 needs to be an integer: nil is invalid
subst_3 needs to be an integer: nil is invalid
target_limit_0 needs to be an integer: nil is invalid
target_limit_1 needs to be an integer: nil is invalid
target_limit_2 needs to be an integer: nil is invalid
cost_limit5 needs to be an integer: nil is invalid
max_gc_fac needs to be an integer: nil is invalid
max_gc_gb needs to be an integer: nil is invalid
max_gc_ode needs to be an integer: nil is invalid
max_gc_red_len needs to be an integer: nil is invalid
max_gc_short needs to be an integer: nil is invalid
max_gc_ss needs to be an integer: nil is invalid
maxalgsys_ needs to be an integer: nil is invalid
max_eqn_to_conti needs to be an integer: nil is invalid
nfct_ needs to be an integer: nil is invalid
nequ_ needs to be an integer: nil is invalid
low_gensep needs to be an integer: nil is invalid
high_gensep needs to be an integer: nil is invalid
length_inc_alg needs to be a number: nil is invalid
length_inc_dec needs to be a number: nil is invalidThe global variable 
length_inc_dec has an incorrect value, please check!
*****   

nodepnd {y}$


lisp(prolong_order:=0)$



end$

Tested on i686-pc-windows CSL
Time (counter 1): 16 ms  plus GC time: 63 ms
1: real 0.34
user 0.04
sys 0.10
