ACN's list of potential Lisp/Reduce related activities, not sorted by
priority, but with a few comments with each...


(1) Make CSL act as a PSL cross-compiler
    Ha Ha Ha. This is not an especially useful idea, but could be fun
    and would help in trying to bring CSL and PSL closer together.
    Low priority!

(2, 3 etc) Some items I had put on this list have been completed and so
    removed. I will keep putting new items on the end.

(4) Conservative Garbage Collection in a mostly-copying style
    I am working on this is "cslplus". When I have a clear run of
    uninterrupted time it is one of my top objectives.

(5) Just-in-Time compilation got fully working for x86 and x86_64 at least
    This would be MUCH easier in a system with a conservative garbage
    collector, so it waits until (4) is done.

(7) PSL/CSL compatibility review
    Ongoing, in that from time to time I merge extra PSL-specific features
    into CSL.

(8) CSL documentation
    I have a framework to put documentation merged in within the CSL source
    code, and a utility to extract it, so I need to keep working on that.

(9) more refinement in TeX-like layout
    A full re-work is probably needed rather than mere incremental changes.

(10) merge back BSD make changes provided by asau.
    Enough time has passed that this is now probably a dead issue.

(11) Cache output from JIT compiler so it can be loaded on subsequent runs?
    adapt to become full ahead-of-time compiler?
    Await conservative garbage collection.

(12) Get wxWidgets local editing and all the rest completed
    Another substantial task that needs time and energy, but if completed it
    would make CSL run in native style on a Macintosh.

(13) pass stuff to (genuine) LaTeX for layout, and merge in wxdvi stuff for
     rendering.
    I tried a first investigation of this and apart frrom the horrid cost
    it sort of worked, but it is not part of a long term solution to
    anything much.

(14) tmprint.red width control
    This needs total rework more than incremental hacking, I fear.
 
(15) tmprint.red and "on list", "on fort" and in general all the odd
     output-related flags
    See (14) above.

(16) 64-bit fixnums (well 60-bits...) when on a 64-bit platform
    Do as part of cslplus?

(17) Jlisp ported to Android
    See that Akra Part II project that shows how the technology can work.
    Now wondering what a full touch-screen interface for computer algebra
    ought to look like is a task for somebody!

(18) port to iPad
    So first wait until Apple relax their current stranglehold on the
    distribution of iPad applications. Do the Android version first!

(19) issues to do with available font sizes and dvi, and sub-pixel positioning.
    Part of the major TeX-like output review that is called for.

(20) Compilation into C should cope with catch, unwind-protect and a few more
     things. Review c-code.red and its blacklist of functions not to
     process and clean things up.
    This counts as tidying up, so should happen sometime but is not utterly
    urgent.

(21) Arrange to be able to compile Lisp into Java for Jlisp and measure
     any speedup that results.
    A potential way to make things a lot nicer for Geogebra by improving the
    performance of the Javascript variant. There will be all the infrastructure
    messinesses about coping with interactions between having direct Java
    implementations of some functions and Reduce's dynamic definition and
    redefinition habits. Should be viewed as fairly high priority, since in
    the C-coded version of the system the corresponding procedure leads to
    a speed improvement of about a factor of around 4, and apart from the
    extra memory used for piles and piled more Java code it is a cheap way to
    get such a useful improvement. Of course until a Java versiion is
    working the performance prospects there remain uncertain!

(22) Consider (21) but compiling from Lisp directly to Java class files
     for immediate use. But note that that would not help Javascript a lot!
    Probably more work than is worthwhile, since I tend to view the Java code
    as a non-mainstream oddity!

(23) Implement catch, throw, unwind-protect within Jlisp
    Necessary since I am now using these within the body of Reduce.

(24) Rubi-red pattern-matching and rewrites to enhance the integrator.
    The Rubi test files and work by S Mitra show that this can make both
    large improvements to the coverage of the integrator and dramatic
    speedups.

(25) cslplus work on conservative garbage collector in a parallel Lisp
     context, and in general bringing cslplus up to a state where it can
     be made the main support p[latform.
    I view this as high priority because it can lead to performance and
    flexibility improvements. A lot of CSL can be re-used in this, but the
    opportunity to rework everything and revisit design decisions made when
    CSL was first created (some of which now feel out of date) seems good.
    
(26) Check all of Reduce and remove every case where there are two functions
     with the same name.
    Where one package deliberately tries to redefine something re-code things
    so there is one definition that tests a flag if it has to exhibit
    alternative behaviour. Similarly work on removing uses of putd and copyd
    at runtime. This will make static analysis and compilation of the code
    easier.

(27) Type-reconstruction style type-checking for Reduce
    Existing Reduce is written in a typeless language (more or less) but
    type-reconstruction should still be able to do a great deal to spot
    errors. There is some delicacy in doing all this without needing to
    rewrite massive amounts of existing Reduce code, but I believe that a lot
    should be possible (especially after (26) has made the code more static!).

(28) Arrange that loading a module never changes system behaviour.
    At present there is a confusion between lading the code that implements
    some feature into memory (typically using load_package) and making the
    feature active. I believe that behaviour changes should be controlled by
    "on" and "off" flags and that loading a package into memory should be
    totally transparent. Eg this would mean one could have a version of
    Reduce with all packages pre-loaded, or a smaller version with only a
    minimal amount memory resident to start with but with autoload schema
    loading stuff as needed. This ought to be a cleaner setup than at present.

(29) Support for "correct" implementation of tail-calls and static scope rules
    in CSL in every case.
