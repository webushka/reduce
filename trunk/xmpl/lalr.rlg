
% Test cases for the parser generator. This all runs in
% symbolic mode...

symbolic;


nil


% Here I set up a sample grammar
%    S' -> S
%    S  -> C C     { A1 }
%    C  -> c C     { A2 }
%        | d       { A3 }
% Example 4.42 from Aho, Sethi and Ullman's Red Dragon book, with
% some dummy semantic actions added. Note that I do not need to insert
% the production S' -> S for myself since the analysis code will
% augment my grammar with it for me anyway.
% Example 4.54 in the more recent Purple book.

grammar := '((S  ((C C) A1))
             (C  ((cc C) A2)
                 ((dd) A3))
            );


((s ((c c) a1)) (c ((cc c) a2) ((dd) a3)))


lalr_construct_parser grammar;

Terminal symbols are:
 cc:268 dd:267
Non-terminal symbols are:
[0]s'               : s                         { }
                    ;
[1]s                : c c                       { a1 }
                    ;
[2]c                : cc c                      { a2 }
                    | dd                        { a3 }
                    ;

Action map:
0:          nil
1:          (a1)
2:          (a2)
3:          (a3)
FIRST sets for each non-terminal:
s':             dd cc
s:              cc dd
c:              dd cc
LR(1) Items:
Item number 0
c -> . cc c  :  cc
c -> . cc c  :  dd
c -> . dd  :  cc
c -> . dd  :  dd
s -> . c c  :  $
s' -> . s  :  $
          dd GOTO state 4
          c GOTO state 2
          cc GOTO state 3
          s GOTO state 1
Item number 1
s' -> s .  :  $
Item number 2
c -> . cc c  :  $
c -> . dd  :  $
s -> c . c  :  $
          dd GOTO state 8
          c GOTO state 6
          cc GOTO state 7
Item number 3
c -> . cc c  :  cc
c -> . cc c  :  dd
c -> . dd  :  cc
c -> . dd  :  dd
c -> cc . c  :  cc
c -> cc . c  :  dd
          dd GOTO state 4
          c GOTO state 5
          cc GOTO state 3
Item number 4
c -> dd .  :  cc
c -> dd .  :  dd
Item number 5
c -> cc c .  :  cc
c -> cc c .  :  dd
Item number 6
s -> c c .  :  $
Item number 7
c -> . cc c  :  $
c -> . dd  :  $
c -> cc . c  :  $
          dd GOTO state 8
          c GOTO state 9
          cc GOTO state 7
Item number 8
c -> dd .  :  $
Item number 9
c -> cc c .  :  $
Merged Items:
Item number 0
c -> . cc c  :  cc
c -> . cc c  :  dd
c -> . dd  :  cc
c -> . dd  :  dd
s -> . c c  :  $
s' -> . s  :  $
          dd GOTO state 4
          c GOTO state 2
          cc GOTO state 3
          s GOTO state 1
Item number 1
s' -> s .  :  $
Item number 2
c -> . cc c  :  $
c -> . dd  :  $
s -> c . c  :  $
          dd GOTO state 4
          c GOTO state 6
          cc GOTO state 3
Item number 3
c -> . cc c  :  cc
c -> . cc c  :  dd
c -> . cc c  :  $
c -> . dd  :  cc
c -> . dd  :  dd
c -> . dd  :  $
c -> cc . c  :  cc
c -> cc . c  :  dd
c -> cc . c  :  $
          dd GOTO state 4
          c GOTO state 5
          cc GOTO state 3
Item number 4
c -> dd .  :  cc
c -> dd .  :  dd
c -> dd .  :  $
Item number 5
c -> cc c .  :  cc
c -> cc c .  :  dd
c -> cc c .  :  $
Item number 6
s -> c c .  :  $
Actions:
0                   dd                  (shift 4)
0                   cc                  (shift 3)
1                   $                   accept
2                   dd                  (shift 4)
2                   cc                  (shift 3)
3                   dd                  (shift 4)
3                   cc                  (shift 3)
4                   $                   reduce c -> dd { 3 }
4                   dd                  reduce c -> dd { 3 }
4                   cc                  reduce c -> dd { 3 }
5                   $                   reduce c -> cc c { 2 }
5                   dd                  reduce c -> cc c { 2 }
5                   cc                  reduce c -> cc c { 2 }
6                   $                   reduce s -> c c { 1 }
ACTION_TABLE = 
(0 (267 (shift 4)) (268 (shift 3)))
(1 (0 accept))
(2 (267 (shift 4)) (268 (shift 3)))
(3 (267 (shift 4)) (268 (shift 3)))
(4 (0 (reduce (c 267) (3))) (267 (reduce (c 267) (3))) (268 (reduce (c 267) (3))
))
(5 (0 (reduce (c 268 c) (2))) (267 (reduce (c 268 c) (2))) (268 (reduce (c 268 c
) (2))))
(6 (0 (reduce (s c c) (1))))
Posn 0 267 / 4
Posn 1 -1 / 3
Posn 2 -1 / 0
Posn 3 267 / 4
Posn 4 -1 / 3
Posn 5 267 / 4
Posn 6 -1 / 3
REDUCE (c 267) : (3)
Semantic Action (1)  ((a3) . 3)
Posn 7 0 / -3
REDUCE (c 267) : (3)
Semantic Action (1)  ((a3) . 3)
Posn 8 267 / -3
REDUCE (c 267) : (3)
Semantic Action (1)  ((a3) . 3)
Posn 9 -1 / -3
REDUCE (c 268 c) : (2)
Semantic Action (2)  ((a2) . 2)
Posn 10 0 / -2
REDUCE (c 268 c) : (2)
Semantic Action (2)  ((a2) . 2)
Posn 11 267 / -2
REDUCE (c 268 c) : (2)
Semantic Action (2)  ((a2) . 2)
Posn 12 -1 / -2
REDUCE (s c c) : (1)
Semantic Action (2)  ((a1) . 1)
Posn 13 -1 / -1
Now fill in the table
action_index #V16(0 2 3 5 7 10 13)
action_terminal #V16(267 -1 -1 267 -1 267 -1 0 267 -1 0 267 -1 -1)
action_result #V16(4 3 0 4 3 4 3 -3 -3 -3 -2 -2 -2 -1)
action_fn [nil nil nil nil]
action_n #V8(2 2 1)
action_A #V16(1 2 2)
0         c GOTO state 2
2         c GOTO state 6
3         c GOTO state 5
0         s GOTO state 1
goto_index: #V16(3 3 0)
goto_old_state: #V16(0 2 -1 -1)
goto_new_state: #V16(2 6 5 1)

nil


yyparse();



cc yylex returns 268
state stack: (0)
sym stack: nil
next input: 268
action code: 3
w = 3
cc state stack: (3 0)
sym stack: (cc)
next input: 268
action code: 3
w = 3
cc state stack: (3 3 0)
sym stack: (cc cc)
next input: 268
action code: 3
w = 3
dd state stack: (3 3 3 0)
sym stack: (cc cc cc)
next input: 267
action code: 4
w = 4
cc state stack: (4 3 3 3 0)
sym stack: (dd cc cc cc)
next input: 268
action code: -3
w = -3
state stack: (5 3 3 3 0)
sym stack: ((dd) cc cc cc)
next input: 268
action code: -2
w = -2
state stack: (5 3 3 0)
sym stack: ((cc (dd)) cc cc)
next input: 268
action code: -2
w = -2
state stack: (5 3 0)
sym stack: ((cc (cc (dd))) cc)
next input: 268
action code: -2
w = -2
state stack: (2 0)
sym stack: ((cc (cc (cc (dd)))))
next input: 268
action code: 3
w = 3
dd state stack: (3 2 0)
sym stack: (cc (cc (cc (cc (dd)))))
next input: 267
action code: 4
w = 4
eof
state stack: (4 3 2 0)
sym stack: (dd cc (cc (cc (cc (dd)))))
next input: 0
action code: -3
w = -3
state stack: (5 3 2 0)
sym stack: ((dd) cc (cc (cc (cc (dd)))))
next input: 0
action code: -2
w = -2
state stack: (6 2 0)
sym stack: ((cc (dd)) (cc (cc (cc (dd)))))
next input: 0
action code: -1
w = -1
state stack: (1 0)
sym stack: (((cc (cc (cc (dd)))) (cc (dd))))
next input: 0
action code: 0
Seem to have finished...
(((cc (cc (cc (dd)))) (cc (dd))))

yyparse();



dd yylex returns 267
state stack: (0)
sym stack: nil
next input: 267
action code: 4
w = 4
dd state stack: (4 0)
sym stack: (dd)
next input: 267
action code: -3
w = -3
state stack: (2 0)
sym stack: ((dd))
next input: 267
action code: 4
w = 4
eof
state stack: (4 2 0)
sym stack: (dd (dd))
next input: 0
action code: -3
w = -3
state stack: (6 2 0)
sym stack: ((dd) (dd))
next input: 0
action code: -1
w = -1
state stack: (1 0)
sym stack: (((dd) (dd)))
next input: 0
action code: 0
Seem to have finished...
(((dd) (dd)))




% Example 4.46 from the Red Dragon (4.61 in Aho, Lam, Sethi and Ullman,
% "Compilers: principles, techniques and tools", second edition 2007).

g4_46 := '((S   ((L "=" R) a1)
                ((R)       a2))
           (L   (("*" R)   a3)
                ((!:symbol)  a4))
           (R   ((L)       a5)));


((s ((l "=" r) a1) ((r) a2)) (l (("*" r) a3) ((!:symbol) a4)) (r ((l) a5)))


lalr_construct_parser g4_46;

One-character string found <:> with code 61
One-character string found <:> with code 42
Terminal symbols are:
 !::42 !:symbol:256
Non-terminal symbols are:
[0]s'               : s                         { }
                    ;
[1]s                : l "=" r                   { a1 }
                    | r                         { a2 }
                    ;
[2]l                : "*" r                     { a3 }
                    | :symbol                   { a4 }
                    ;
[3]r                : l                         { a5 }
                    ;

Action map:
0:          nil
1:          (a1)
2:          (a2)
3:          (a3)
4:          (a4)
5:          (a5)
FIRST sets for each non-terminal:
s':             !:symbol 267 268
s:              !:symbol 268 267
l:              !:symbol
r:              !:symbol
LR(1) Items:
Item number 0
l -> . "*" r  :  $
l -> . !:symbol  :  $
r -> . l  :  $
s -> . l "=" r  :  $
s -> . r  :  $
s' -> . s  :  $
          r GOTO state 3
          !:symbol GOTO state 4
          l GOTO state 2
          s GOTO state 1
Item number 1
s' -> s .  :  $
Item number 2
r -> l .  :  $
s -> l . "=" r  :  $
Item number 3
s -> r .  :  $
Item number 4
l -> !:symbol .  :  $
Merged Items:
Item number 0
l -> . "*" r  :  $
l -> . !:symbol  :  $
r -> . l  :  $
s -> . l "=" r  :  $
s -> . r  :  $
s' -> . s  :  $
          !:symbol GOTO state 4
          r GOTO state 3
          s GOTO state 1
          l GOTO state 2
Item number 1
s' -> s .  :  $
Item number 2
r -> l .  :  $
s -> l . "=" r  :  $
Item number 3
s -> r .  :  $
Item number 4
l -> !:symbol .  :  $
Actions:
0                   !:symbol            (shift 4)
1                   $                   accept
2                   $                   reduce r -> l { 5 }
3                   $                   reduce s -> r { 2 }
4                   $                   reduce l -> !:symbol { 4 }
ACTION_TABLE = 
(0 (256 (shift 4)))
(1 (0 accept))
(2 (0 (reduce (r l) (5))))
(3 (0 (reduce (s r) (2))))
(4 (0 (reduce (l 256) (4))))
Posn 0 -1 / 4
Posn 1 -1 / 0
REDUCE (r l) : (5)
Semantic Action (1)  ((a5) . 5)
Posn 2 -1 / -5
REDUCE (s r) : (2)
Semantic Action (1)  ((a2) . 2)
Posn 3 -1 / -2
REDUCE (l 256) : (4)
Semantic Action (1)  ((a4) . 4)
Posn 4 -1 / -4
Now fill in the table
action_index #V16(0 1 2 3 4)
action_terminal #V16(-1 -1 -1 -1 -1)
action_result #V16(4 0 -5 -2 -4)
action_fn [nil nil nil nil nil nil]
action_n #V8(0 1 0 1 1)
action_A #V16(0 1 0 2 3)
0         r GOTO state 3
0         s GOTO state 1
0         l GOTO state 2
goto_index: #V16(1 1 2 0)
goto_old_state: #V16(-1 -1 -1)
goto_new_state: #V16(3 1 2)

nil


yyparse();



leftsym yylex returns 256
state stack: (0)
sym stack: nil
next input: 256
action code: 4
w = 4
= state stack: (4 0)
sym stack: (!:symbol)
next input: 61
action code: -4
w = -4
state stack: (2 0)
sym stack: ((!:symbol))
next input: 61
action code: -5
w = -5
state stack: (3 0)
sym stack: (((!:symbol)))
next input: 61
action code: -2
w = -2
state stack: (1 0)
sym stack: ((((!:symbol))))
next input: 61
action code: 0
Seem to have finished...
((((!:symbol))))
rightsym eof


yyparse();



***yylex returns 94
state stack: (0)
sym stack: nil
next input: 94
action code: 4
w = 4
+++ Error: intern (not a string) 94
*xxx = *x eof

end;

nil
Tested on x86_64-pc-windows CSL
Time (counter 1): 0 ms

End of Lisp run after 0.00+0.06 seconds
real 0.18
user 0.00
sys 0.07
