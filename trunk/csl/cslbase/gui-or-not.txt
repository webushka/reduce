Launching Reduce
================

When Reduce is launched it can start up in either command line or
windowed mode. The simple situation is when the user provides explicit
command-line options that instruct it which to try:

   reduce --gui       open a window.
   reduce --nogui     run in current terminal.
   reduce --guimin    open a window, but initially minimised.

When one of these options is given the system tries to follow instructions.
If that leads to failure then it will make a "best efforts" attempt to
report back to the user, but in extreme cases it may be failing because
it is unable to establish any communication link at all, and the failure
will necessarily be fairly silent.

The above options have short forms that were the only versions present in
earlier releases of the software:

   --gui       -w+
   --nogui     -w   or   -w-
   --guimin    -w.

These short options act as simple synonyms for the longer names and so do
not introduce any additional functionality.

The interesting case arises when none of these options are specified. The
system will try to make what it hopes will count as an intelligent choice.
The principle followed is that if Reduce is being invoked via a pipe or
with its standard input or output redirected then that suggests that it
is expected to take its input from the standard input, and hence it should
run in console mode. Also if it will be unable to create a window it
should run in console mode. Otherwise (and this is expected to be the most
common case) it should run in windowed mode.

On a system that uses X11 the policy can be well approximated by testing
isatty(fileno(stdin)) and getenv("DISPLAY"). If stdin (or stdout) is
not attached to a "tty" or if there is no display for X11 to use then the
code should run in console mode. In some ways this is logically twisted
since the test is as to whether stdin and stdout are available and connect
directly to the user, and if they are the program will launch a window and
interact via that rather than via the standard streams! But the reasoning is
that stdin and stdout not being attached to the console represents a special
circumstance that calls for IO involving them to be performed.

On Windows there are a number of issues that make the situation seriously
more messy:
 (1) an application can be linked in "windowed" or "console" mode. A
     windowed application detaches from any console it may have during
     its startup (before code could override that behaviour) while a
     console application will tend to create a visible console to use
     in a way that is most distracting in the case that that is not
     actually required.
 (2) When run from the current standard cygwin terminal (mintty) the
     Windows API reports both stdin and stdout as connected to pipes
     not the keyboard or screen, and Windows screen management calls
     are not available - making line-editing of input a serious problem.
     However when the same binary is run from the older (cmd-based)
     cygwin shell stdin and stdout do show up as "tty"s, and the proper
     way to manage the screen will be via the Windows API.
     Windows appears not to provide a (clean?) way to identify a parent
     process or distinguish nicely between these cases.
 (3) Windows executables can have suffixes ".com" or ".exe" and different
     shells will choose one over the other. And programs can be launched
     by double-clicking an icon as well as by typing a program name.
     This multiplies the number of variations on launch configurations
     painfully.


On Windows my resolution of this will be that in the directory where binary
versions of Reduce live I will have the following five files:

    reduce             a /bin/sh shell script
    reduce.com         a native windows console binary
    reduce.exe         a native windows "windows mode" binary
    cygwin-reduce.exe  reduce build for use under cygwin, with X11 support
    not-under-cygwin.exe   a utility program explained below

The script named plain "reduce" will have at its core
   if not-under-cygwin $*
   then
      reduce.com $*
   else
      cygwin-reduce.exe $*
   fi
but will need additional coding to allow it to specify reliable paths
to find the various executables on. Any desktop or start-menu link should
refer to reduce.exe.

The behaviour should then be as follows:

If Reduce is launched by double-clicking an icon then that starts up
reduce.exe, which had been linked as a window-mode application and so
does not create a spurious console. In this case only windowed execution
is supported.

If the launch is from a traditional DOS shell and the user types the
word "reduce" then "reduce.com" will be launched in preference to either
"reduce" or "reduce.exe". This is the native Windows console mode version.
It can start a window if it wants to, but it also has full access to the
Windows console that launched it.

There are several cases to consider when Reduce is being launched
from some other form of command-line, but in all cases the expectation is
this is some Unix-compatible shell. In such a case the command "reduce"
should resolve and run the script "reduce". This runs a program to judge
which version of Reduce to use. Such a step slows down the process of
starting the system but provides a great deal of flexibility. So all the
uncertainty gets migrated into the "reduce" script and the program that
it invokes.

The program is compiled as a native windows program and so does not need
any external resources (eg special dlls etc). It starts by calling
the function GetConsoleScreenBufferInfo() on a handle that should refer
to the standard output. If this call succeeds then the scripts is presumed
to have been called from some Unix-like shell (eg perhaps "bash") running
directly from an ordinary Windows console. In that case invoking reduce.com
will be sensible because all normal aspects of the Windows API will be
available.

If GetConsoleScreenBufferInfo() fails then the shell script is liable to
have been invoked from mintty, a terminal running in an X-window (eg
xterm) or via ssh. In all those cases if Reduce is going to end up running
in console mode then it should be invoked as cygwin-reduce.exe since that
binary will know how to interact with the cygwin modelling of ptys that
provide terminal control. Just for now I intend to ignore the though of
some X server other than the cygwin one...

In the case that the invocation is from mintty then the best default
behaviour would be that any attempt to run as windowed should be via the
native Windows scheme (ie using reduce.com), but if use is from an X
terminal or ssh that should not be attempted and windowing if at all should
use X11.



